// Generated by CoffeeScript 2.5.1
(function() {
  'use strict';
  var CND, badge, debug, echo, help, info, inspect, isa, jr, rpr, test, test_basics, type_of, types, urge, validate, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'DATOM/TESTS/VNR';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  test = require('guy-test');

  jr = JSON.stringify;

  //...........................................................................................................
  types = require('../types');

  ({isa, validate, type_of} = types);

  //...........................................................................................................
  ({inspect} = require('util'));

  rpr = function(...P) {
    var x;
    return ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = P.length; i < len; i++) {
        x = P[i];
        results.push(inspect(x, {
          depth: 2e308,
          maxArrayLength: 2e308,
          breakLength: 2e308,
          compact: true
        }));
      }
      return results;
    })()).join(' ');
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @[ "VNR 1" ] = ( T, done ) ->
  //   VNR                       = require '../vnr'
  //   DATOM                     = new ( require '../..' ).Datom { merge_values: false, }
  //   { new_datom
  //     select }                = DATOM.export()
  //   #.........................................................................................................
  //   probes_and_matchers = [
  //     [["^number",null],{"$key":"^number"},null]
  //     ]
  //   #.........................................................................................................
  //   for [ probe, matcher, error, ] in probes_and_matchers
  //     await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->
  //       [ key, value, ] = probe
  //       debug '^223-1^', d = VNR.new_vnr()
  //       debug '^223-2^', d = VNR.new_vnr      [ 4, 6, 5, ]
  //       debug '^223-3^', d = VNR.deepen       d
  //       debug '^223-4^', d = VNR.deepen       d, 42
  //       debug '^223-5^', d = VNR.advance      d
  //       debug '^223-6^', d = VNR.recede       d
  //       # debug '^223-7^', d = VNR._lower_bound d
  //       # debug '^223-8^', d = VNR._upper_bound d
  //       resolve new_datom key, value
  //   done()
  //   return null

  //-----------------------------------------------------------------------------------------------------------
  test_basics = function(T, VNR) {
    var d;
    T.eq((d = VNR.new_vnr()), [0]);
    T.eq((d = VNR.new_vnr([4, 6, 5])), [4, 6, 5]);
    T.eq((d = VNR.deepen(d)), [4, 6, 5, 0]);
    T.eq((d = VNR.deepen(d, 42)), [4, 6, 5, 0, 42]);
    T.eq((d = VNR.advance(d)), [4, 6, 5, 0, 43]);
    T.eq((d = VNR.recede(d)), [4, 6, 5, 0, 42]);
    T.ok((VNR.new_vnr(d)) !== d);
    T.ok((VNR.deepen(d)) !== d);
    T.ok((VNR.advance(d)) !== d);
    T.ok((VNR.recede(d)) !== d);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["VNR 1"] = function(T, done) {
    test_basics(T, require('../vnr'));
    test_basics(T, (require('../..')).VNR);
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["VNR sort 2"] = async function(T, done) {
    var VNR, i, j, len, len1, matcher, matchers, ordering, probe, ref, ref1;
    matchers = {
      total: [[[1], [1, 0], [1, 0, -1], [1, 0, 1], [2], [2, -1], [2, 0], [2, 1]], [[2e308], [2e308, -1], [2e308, 1]], [[2e308, -1], [2e308, 0], [2e308, 1]]],
      partial: [[[1, 0, -1], [1], [1, 0], [1, 0, 1], [2, -1], [2, 0], [2], [2, 1]], [[1, 0, -1], [1, 0], [1], [1, 0, 1], [2, -1], [2], [2, 0], [2, 1]], [[2, 0], [2]], [[2], [2, 0]], [[2e308, -1], [2e308], [2e308, 1]], [[2e308, -1], [2e308, 0], [2e308, 1]]],
      fair: [[[1, 0, -1], [1], [1, 0], [1, 0, 1], [2, -1], [2], [2, 0], [2, 1]], [[2], [2, 0]], [[2e308, -1], [2e308], [2e308, 1]], [[2e308, -1], [2e308, 0], [2e308, 1]], [[1]], [[1], [2]]]
    };
    ref = ['total', 'partial', 'fair'];
    for (i = 0, len = ref.length; i < len; i++) {
      ordering = ref[i];
      VNR = new (require('../..')).VNR.Vnr({ordering});
      ref1 = matchers[ordering];
      // VNR     = new ( require '../..' ).VNR.Vnr { ordering, validate: false, }
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        matcher = ref1[j];
        probe = [...matcher];
        await T.perform(probe, matcher, null, function() {
          return new Promise(function(resolve, reject) {
            var result;
            result = VNR.sort(probe);
            T.ok(probe !== matcher);
            T.ok(probe !== result);
            T.eq(result, matcher);
            // debug '^334^', rpr result
            return resolve(result);
          });
        });
      }
    }
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["VNR sort 3"] = function(T, done) {
    var VNR;
    VNR = (require('../..')).VNR;
    info(CND.blue('cmp_total    ', "[ 1, ],     [ 1, -1, ]", VNR.cmp_total([1], [1, -1])));
    info(CND.blue('cmp_total    ', "[ 1, ],     [ 1,  0, ]", VNR.cmp_total([1], [1, 0])));
    info(CND.blue('cmp_total    ', "[ 1, ],     [ 1, +1, ]", VNR.cmp_total([1], [1, +1])));
    info(CND.blue('cmp_total    ', "----------------------"));
    info(CND.blue('cmp_total    ', "[ 1, 0, ],  [ 1, -1, ]", VNR.cmp_total([1, 0], [1, -1])));
    info(CND.blue('cmp_total    ', "[ 1, 0, ],  [ 1,  0, ]", VNR.cmp_total([1, 0], [1, 0])));
    info(CND.blue('cmp_total    ', "[ 1, 0, ],  [ 1, +1, ]", VNR.cmp_total([1, 0], [1, +1])));
    info();
    info(CND.lime('cmp_partial  ', "[ 1, ],     [ 1, -1, ]", VNR.cmp_partial([1], [1, -1])));
    info(CND.lime('cmp_partial  ', "[ 1, ],     [ 1,  0, ]", VNR.cmp_partial([1], [1, 0])));
    info(CND.lime('cmp_partial  ', "[ 1, ],     [ 1, +1, ]", VNR.cmp_partial([1], [1, +1])));
    info(CND.lime('cmp_partial  ', "----------------------"));
    info(CND.lime('cmp_partial  ', "[ 1, 0, ],  [ 1, -1, ]", VNR.cmp_partial([1, 0], [1, -1])));
    info(CND.lime('cmp_partial  ', "[ 1, 0, ],  [ 1,  0, ]", VNR.cmp_partial([1, 0], [1, 0])));
    info(CND.lime('cmp_partial  ', "[ 1, 0, ],  [ 1, +1, ]", VNR.cmp_partial([1, 0], [1, +1])));
    info();
    info(CND.steel('cmp_fair     ', "[ 1, ],     [ 1, -1, ]", VNR.cmp_fair([1], [1, -1])));
    info(CND.steel('cmp_fair     ', "[ 1, ],     [ 1,  0, ]", VNR.cmp_fair([1], [1, 0])));
    info(CND.steel('cmp_fair     ', "[ 1, ],     [ 1, +1, ]", VNR.cmp_fair([1], [1, +1])));
    info(CND.steel('cmp_fair     ', "----------------------"));
    info(CND.steel('cmp_fair     ', "[ 1, 0, ],  [ 1, -1, ]", VNR.cmp_fair([1, 0], [1, -1])));
    info(CND.steel('cmp_fair     ', "[ 1, 0, ],  [ 1,  0, ]", VNR.cmp_fair([1, 0], [1, 0])));
    info(CND.steel('cmp_fair     ', "[ 1, 0, ],  [ 1, +1, ]", VNR.cmp_fair([1, 0], [1, +1])));
    done();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this["test for stable sort 2"] = function(T, done) {
    var ds, i, is_stable, len, m, n, nr, prv_nr, prv_r, r;
    n = 1e4;
    m = Math.floor(n / 3);
    ds = (function() {
      var i, ref, results;
      results = [];
      for (nr = i = 1, ref = n; (1 <= ref ? i <= ref : i >= ref); nr = 1 <= ref ? ++i : --i) {
        results.push([nr, CND.random_integer(-m, +m)]);
      }
      return results;
    })();
    ds.sort(function(a, b) {
      return a[1] - b[1];
    });
    prv_r = -2e308;
    prv_nr = -2e308;
    is_stable = true;
    for (i = 0, len = ds.length; i < len; i++) {
      [nr, r] = ds[i];
      if (r === prv_r) {
        is_stable = is_stable && nr > prv_nr;
      }
      prv_r = r;
      prv_nr = nr;
    }
    T.ok(is_stable);
    return done();
  };

  //-----------------------------------------------------------------------------------------------------------
  this["test VNR._first_nonzero_is_negative()"] = async function(T, done) {
    var VNR, error, i, len, matcher, probe, probes_and_matchers;
    VNR = require('../vnr');
    //.........................................................................................................
    probes_and_matchers = [[[[3, 4, 0, 0], 2], false], [[[3, 4, 0, -1], 2], true], [[[3, 4, 0, -1, 0, 0], 2], true], [[[3, 4, 0, 1, -1, 0, 0], 2], false], [[[3, 4, 0, 1, -1, 0, 0], 0], false], [[[3, 4, 0, 0], 3], false], [[[3, 4, 0, 0], 4], false]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher, error] = probes_and_matchers[i];
      await T.perform(probe, matcher, error, function() {
        return new Promise(function(resolve, reject) {
          var first_idx, list;
          [list, first_idx] = probe;
          return resolve(VNR._first_nonzero_is_negative(list, first_idx));
        });
      });
    }
    done();
    return null;
  };

  //###########################################################################################################
  if (require.main === module) {
    (() => {
      return test(this);
    })();
  }

  // test @[ "VNR sort 2" ]
// test @[ "VNR sort 3" ]
// @[ "VNR sort 3" ]()
// test @[ "test VNR._first_nonzero_is_negative()" ]

}).call(this);

//# sourceMappingURL=vnr.test.js.map
