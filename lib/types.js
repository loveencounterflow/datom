// Generated by CoffeeScript 2.5.0
(function() {
  'use strict';
  var CND, Intertype, alert, badge, debug, help, info, intertype, jr, rpr, tagname_head_pattern, tagname_pattern, tagname_tail_pattern, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'DATOM/TYPES';

  debug = CND.get_logger('debug', badge);

  alert = CND.get_logger('alert', badge);

  whisper = CND.get_logger('whisper', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  info = CND.get_logger('info', badge);

  jr = JSON.stringify;

  Intertype = (require('intertype')).Intertype;

  intertype = new Intertype(module.exports);

  //-----------------------------------------------------------------------------------------------------------
  this.declare('datom_settings', {
    tests: {
      "x is a object": function(x) {
        return this.isa.object(x);
      },
      "x.merge_values is a ?boolean": function(x) {
        return (x.merge_values == null) || this.isa.boolean(x.merge_values);
      },
      "x.freeze is a ?boolean": function(x) {
        return (x.freeze == null) || this.isa.boolean(x.freeze);
      }
    }
  });

  //-----------------------------------------------------------------------------------------------------------
  this.declare('datom_nonempty_list_of_positive_integers', function(x) {
    if (!this.isa.nonempty_list(x)) {
      return false;
    }
    return x.every((xx) => {
      return this.isa.positive_integer(xx);
    });
  });

  //-----------------------------------------------------------------------------------------------------------
  this.declare('datom_sigil', {
    tests: {
      "x is a chr": function(x) {
        return this.isa.chr(x);
      },
      "x has sigil": function(x) {
        return indexOf.call('^<>~[]', x) >= 0;
      }
    }
  });

  //-----------------------------------------------------------------------------------------------------------
  this.declare('datom_key', {
    tests: {
      "x is a nonempty text": function(x) {
        return this.isa.nonempty_text(x);
      },
      "x has sigil": function(x) {
        return this.isa.datom_sigil(x[0]);
      }
    }
  });

  //-----------------------------------------------------------------------------------------------------------
  this.declare('datom_datom', {
    tests: {
      "x is a object": function(x) {
        return this.isa.object(x);
      },
      "x.$key is a datom_key": function(x) {
        return this.isa.datom_key(x.$key);
      },
      "x.$stamped is an optional boolean": function(x) {
        return (x.$stamped == null) || (this.isa.boolean(x.$stamped));
      },
      "x.$dirty is an optional boolean": function(x) {
        return (x.$dirty == null) || (this.isa.boolean(x.$dirty));
      },
      "x.$fresh is an optional boolean": function(x) {
        return (x.$fresh == null) || (this.isa.boolean(x.$fresh));
      },
      //.......................................................................................................
      "x.$vnr is an optional nonempty list of positive integers": function(x) {
        return (x.$vnr == null) || this.isa.datom_nonempty_list_of_positive_integers(x.$vnr);
      }
    }
  });

  //===========================================================================================================
  // DEFAULTS, CASTS
  //-----------------------------------------------------------------------------------------------------------
  this.defaults = {
    settings: {
      merge_values: true,
      freeze: true,
      dirty: true
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this.cast = {};

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  /* thx to https://www.w3.org/TR/xml */
  tagname_head_pattern = /a-zA-Z:_\xc0-\xd6\xd8-\xf6\u00f8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c-\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd\u{10000}-\u{effff}/u;

  tagname_tail_pattern = /\.-0-9\xb7\u0300-\u036f\u203f-\u2040/u;

  tagname_pattern = RegExp(`^[${tagname_head_pattern.source}][${tagname_head_pattern.source}${tagname_tail_pattern.source}]*$`, "u");

  //-----------------------------------------------------------------------------------------------------------
  this./* must NOT set global flag */declare('datom_html_tagname', {
    tests: {
      "x is a text": function(x) {
        return this.isa.text(x);
      },
      "x matches tagname_pattern": function(x) {
        return tagname_pattern.test(x);
      }
    }
  });

  //-----------------------------------------------------------------------------------------------------------
  this.declare('datom_html_naked_attribute_value', {
    /* thx to https://raw.githubusercontent.com/mathiasbynens/mothereff.in/master/unquoted-attributes/eff.js
     also see https://mothereff.in/unquoted-attributes,
     https://mathiasbynens.be/notes/unquoted-attribute-values */
    tests: {
      "x is a text": function(x) {
        return this.isa.text(x);
      },
      "x isa datom_html_naked_attribute_text": function(x) {
        return this.isa._datom_html_naked_attribute_text(x);
      }
    }
  });

  //-----------------------------------------------------------------------------------------------------------
  this.declare('_datom_html_naked_attribute_text', function(x) {
    return /^[^ \t\n\f\r"'`=<>]+$/.test(x);
  });

  // #-----------------------------------------------------------------------------------------------------------
// @_CSS_must_quote = ( x ) ->
//   ### NOTE for completeness, from the same source https://mathiasbynens.be/notes/unquoted-attribute-values ###
//   return true if ( x is '' ) or ( x is '-' )
//   ### Escapes are valid, so replace them with a valid non-empty string ###
//   x = ( x.replace /\\([0-9A-Fa-f]{1,6})[ \t\n\f\r]?/g, 'a' ).replace /\\./g, 'a'
//   return not not ( ( /[\0-\x2C\x2E\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x9F]/.test x ) or ( /^-?\d/.test x ) )

}).call(this);

//# sourceMappingURL=types.js.map
