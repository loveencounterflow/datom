{
  "version": 3,
  "file": "vnr.js",
  "sourceRoot": "..",
  "sources": [
    "src/vnr.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'DATOM/VNR'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n{ jr\n  assign }                = CND\n#...........................................................................................................\ntypes                     = require './types'\n{ isa\n  defaults\n  validate }              = types\nMultimix                  = require 'multimix'\nLFT                       = require 'letsfreezethat'\n\n#-----------------------------------------------------------------------------------------------------------\n@new_vnr = ( source = null ) ->\n  if source? then validate.vnr source else source = [ 0, ]\n  return assign [], source\n\n#-----------------------------------------------------------------------------------------------------------\n@deepen = ( d, nr = 0 ) ->\n  ### Given a vectorial line number `vnr`, return a copy of `vnr`, call it\n  `vnr0`, which has an index of `0` appended, thus representing the pre-first `vnr` for a level of lines\n  derived from the one that the original `vnr` pointed to. ###\n  validate.vnr d if @settings.validate\n  return [ d..., nr, ]\n\n#-----------------------------------------------------------------------------------------------------------\n@advance      = ( d ) -> @_advance_or_recede d, +1\n@recede       = ( d ) -> @_advance_or_recede d, -1\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_lower_bound = ( vnr ) ->\n#   ### Return a new VNR `z` such that `( as_hollerith vnr ) > ( as_hollerith z )` holds; this is needed to\n#   iterate over all rows within a given limit. ###\n#   validate.vnr vnr\n#   return [ vnr[ 0 ] - 1 ]\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_upper_bound = ( vnr ) ->\n#   ### Return a new VNR `z` such that `( as_hollerith vnr ) < ( as_hollerith z )` holds; this is needed to\n#   iterate over all rows within a given limit. ###\n#   validate.vnr vnr\n#   return [ vnr[ 0 ] + 1 ]\n\n#-----------------------------------------------------------------------------------------------------------\n@_advance_or_recede = ( d, delta ) ->\n  ### Given a vectorial line number `vnr`, return a copy of `vnr`, call it\n  `vnr0`, which has its last index incremented by `1`, thus representing the vectorial line number of the\n  next line in the same level that is derived from the same line as its predecessor. ###\n  validate.vnr d if @settings.validate\n  R                   = assign [], d\n  R[ d.length - 1 ]  += delta\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@cmp_total = ( a, b ) ->\n  ### Given two VNRs `ğ–†` and `ğ–‡`, return `-1` if `ğ–†` comes lexicographically before `ğ–‡`, `+1` if `ğ–†` comes\n  after `ğ–‡` and `0` if `ğ–†` equals `ğ–‡`. This works by comparing all integers in `ğ–†` and `ğ–‡` in a pairwise\n  fashion and stopping at the first difference; if no difference is found, then either `ğ–†` equals `ğ–‡` or\n  else `ğ–†` is the prefix of `ğ–‡` (so `ğ–†` comes before `ğ–‡`) or vice versa. Because this method provides a\n  *total* ordering over all VNRsâ€”that is, any two VNRs are either identical (`ğ–† â‰ ğ–‡ â‡” ğ–† = ğ–‡`) or else the\n  one comes before the otherâ€”it is called `cmp_total`. ###\n  if @settings.validate\n    validate.vnr a\n    validate.vnr b\n  min_idx = ( Math.min a.length, b.length ) - 1\n  for idx in [ 0 .. min_idx ]\n    ai = a[ idx ]\n    bi = b[ idx ]\n    return -1 if ai < bi\n    return +1 if ai > bi\n  return -1 if a.length < b.length\n  return +1 if a.length > b.length\n  return  0\n\n#-----------------------------------------------------------------------------------------------------------\n@cmp_partial = ( a, b ) ->\n  ### Like `cmp_total()`, but returns `0` in case either VNR is a prefix of the other, that is to say, e.g.\n  `[ 4, 7, ]` is equivalent to `[ 4, 7, 0, ]`, `[ 4, 7, 0, 0, ]` and so on. This is not a total ordering\n  because `[ 4, 7, ]` is clearly not equal to `[ 4, 7, 0, ]` and so on, yet is considered to be in the same\n  position; therefore, the relative ordering of these two VNRs is undefined. Since such an ordering is\n  called partial this method has been called `cmp_partial`.\n\n  `cmp_partial()` is the default ordering method for VNRs because it allows to add arbitrary numbers of\n  items in a sequence before or after a given position (the reference) *without having to modify any\n  existing item*, only by knowing the reference's VNR. This is because `[ x, -1, ] â‰º ( [ x, 0, ] â‰ [ x, ] )\n  â‰º [ x, +1, ]` in partial ordering ###\n  if @settings.validate\n    validate.vnr a\n    validate.vnr b\n  max_idx = ( Math.max a.length, b.length ) - 1\n  for idx in [ 0 .. max_idx ]\n    ai = a[ idx ] ? 0\n    bi = b[ idx ] ? 0\n    return -1 if ai < bi\n    return +1 if ai > bi\n  return  0\n\n#-----------------------------------------------------------------------------------------------------------\n@_first_nonzero_is_negative = ( list, first_idx ) ->\n  idx = first_idx\n  loop\n    if ( R = list[ idx ] ) is 0\n      idx++\n      continue\n    return false if ( R is undefined ) or ( R > 0 )\n    return true\n\n#-----------------------------------------------------------------------------------------------------------\n@cmp_fair = ( a, b ) ->\n  if @settings.validate\n    validate.vnr a\n    validate.vnr b\n  a_length  = a.length\n  b_length  = b.length\n  min_idx   = ( Math.min a_length, b_length ) - 1\n  for idx in [ 0 .. min_idx ]\n    ai = a[ idx ]\n    bi = b[ idx ]\n    return -1 if ai < bi\n    return +1 if ai > bi\n  return  0 if a_length is b_length\n  if a_length < b_length\n    return +1 if @_first_nonzero_is_negative b, min_idx + 1\n    return -1\n  return -1 if @_first_nonzero_is_negative a, min_idx + 1\n  return +1\n\n#-----------------------------------------------------------------------------------------------------------\n@sort = ( vnrs ) ->\n  ### Given a list of VNRs, return a copy of the list with the VNRs lexicographically sorted. ###\n  validate.list vnrs if @settings.validate\n  return ( assign [], vnrs ).sort @_cmp\n\n\n#===========================================================================================================\n# EXPORT\n#-----------------------------------------------------------------------------------------------------------\nMAIN = @\nclass Vnr extends Multimix\n  @include MAIN, { overwrite: false, }\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( settings = null ) ->\n    super()\n    validate.datom_vnr_settings settings = { defaults.vnr_settings..., settings..., }\n    @settings = LFT.freeze settings\n    @Vnr      = Vnr\n    @_cmp     = switch @settings.ordering\n      when 'fair'     then @cmp_fair.bind     @\n      when 'partial'  then @cmp_partial.bind  @\n      when 'total'    then @cmp_total.bind    @\n      else throw new Error \"^409883^ internal error: illegal value for settings.ordering: #{rpr @settings.ordering}\"\n    return @\n\nmodule.exports = new Vnr()\n\n\n"
  ]
}